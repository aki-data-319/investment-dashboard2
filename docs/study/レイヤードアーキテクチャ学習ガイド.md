# レイヤードアーキテクチャ 完全学習ガイド

**対象**: 投資ダッシュボード v2 開発者  
**レベル**: 初心者〜中級者  
**学習時間**: 約60分  

---

## 📖 目次

1. [レイヤードアーキテクチャとは](#1-レイヤードアーキテクチャとは)
2. [なぜレイヤーに分けるのか](#2-なぜレイヤーに分けるのか)
3. [投資ダッシュボードでの実例](#3-投資ダッシュボードでの実例)
4. [各層の詳細解説](#4-各層の詳細解説)
5. [依存関係のルール](#5-依存関係のルール)
6. [実践演習](#6-実践演習)
7. [よくある間違いと対策](#7-よくある間違いと対策)
8. [発展的なトピック](#8-発展的なトピック)

---

## 1. レイヤードアーキテクチャとは

### 🏗️ 基本概念

**レイヤードアーキテクチャ**は、ソフトウェアを複数の「層（レイヤー）」に分割する設計パターンです。

```
🍰 ケーキに例えると...

┌─────────────────┐
│   🍒 トッピング    │ ← Presentation Layer (見た目)
├─────────────────┤
│   🧁 クリーム     │ ← Application Layer (味の調整)
├─────────────────┤  
│   🍰 スポンジ     │ ← Business Layer (主要な味)
├─────────────────┤
│   🥧 土台        │ ← Data Layer (基礎)
└─────────────────┘
```

### 🎯 核心原則

1. **単一責務**: 各層は1つの明確な責務を持つ
2. **一方向依存**: 上位層は下位層にのみ依存
3. **抽象化**: 各層は下位層の実装詳細を知らない
4. **置換可能**: 同一層内で実装を入れ替え可能

---

## 2. なぜレイヤーに分けるのか

### 🔧 技術的メリット

#### **保守性（Maintainability）**
```javascript
// ❌ 層がない場合：すべてが絡み合う
function importCsv(file) {
    // UI処理、データ解析、計算、保存が混在
    const reader = new FileReader();
    reader.readAsText(file, 'Shift_JIS'); // 技術的詳細
    const sector = determineSector(code);  // ビジネスロジック
    localStorage.setItem(key, data);       // データ保存
    updateUI(result);                      // UI更新
}

// ✅ 層がある場合：責務が分離されている
function importCsv(file) {
    // この関数は「調整」のみ担当
    const parsed = csvParser.parse(file);      // Infrastructure
    const withSector = sectorService.assign(parsed); // Business
    const saved = repository.save(withSector);       // Data
    view.display(saved);                             // Presentation
}
```

#### **テスタビリティ（Testability）**
```javascript
// 各層を独立してテスト可能
describe('SectorService', () => {
    it('should assign correct sector for Toyota', () => {
        const sectorService = new SectorService();
        const stock = { code: '7203', name: 'トヨタ自動車' };
        
        const result = sectorService.assignSector(stock);
        
        expect(result.sector).toBe('自動車');
    });
});
```

#### **再利用性（Reusability）**
```javascript
// SectorServiceは複数の場所で使える
class CsvImportService {
    constructor() {
        this.sectorService = new SectorService(); // 再利用
    }
}

class PortfolioAnalyzer {
    constructor() {
        this.sectorService = new SectorService(); // 同じサービスを再利用
    }
}
```

### 💼 ビジネス的メリット

1. **チーム分担**: UI担当者とビジネスロジック担当者で分業
2. **技術変更対応**: データベース変更時、他の層への影響最小
3. **段階的開発**: 下位層から上位層へ順次構築

---

## 3. 投資ダッシュボードでの実例

### 🏢 システム構成図

```
📱 投資ダッシュボード v2 レイヤー構成

┌─────────────────────────────────────────────────┐
│  🖼️  Presentation Layer (UI層)                  │
│  src/ui/                                       │  
│  ├── views/       📺 HTML描画・レイアウト        │
│  ├── controllers/ 🎮 ユーザー操作・イベント処理   │  
│  └── components/  🧩 再利用可能なUI部品          │
├─────────────────────────────────────────────────┤
│  🧠  Application Layer (Services層)             │
│  src/services/                                 │
│  ├── CsvImportService.js    📊 CSV取り込み業務  │
│  ├── PortfolioService.js    💼 ポートフォリオ管理│
│  └── ReportService.js       📋 レポート生成     │
├─────────────────────────────────────────────────┤  
│  💼  Business Layer (ビジネス層)                 │
│  src/business/                                 │
│  ├── services/   🧮 セクター分析・リスク計算     │
│  ├── models/     📦 エンティティ・バリューオブジェクト│
│  └── analysis/   📈 投資分析アルゴリズム         │
├─────────────────────────────────────────────────┤
│  🏪  Data Layer (データ層)                      │  
│  src/data/                                     │
│  ├── managers/     💾 LocalStorage管理         │
│  ├── repositories/ 🗄️ CRUD操作抽象化           │
│  └── migrations/   🔄 データマイグレーション     │
├─────────────────────────────────────────────────┤
│  🔌  Infrastructure Layer (基盤層)              │
│  src/infrastructure/                           │
│  ├── parsers/    📄 CSV・外部データ解析        │
│  ├── apis/       🌐 外部API連携               │
│  └── utils/      🛠️ 技術的ユーティリティ       │
└─────────────────────────────────────────────────┘
```

### 🔄 データフロー例：CSV取り込み

```
👤 ユーザー: CSVファイルをアップロード
    ⬇️
🖼️ UI Layer: ファイル選択イベントを受信
    ⬇️
🧠 Application Layer: CSV取り込み処理を開始
    ⬇️
🔌 Infrastructure Layer: CSVファイルを解析
    ⬇️  
💼 Business Layer: セクター分類・リスク計算
    ⬇️
🏪 Data Layer: データベースに保存
    ⬇️
🧠 Application Layer: 結果を統合
    ⬇️
🖼️ UI Layer: 結果をユーザーに表示
    ⬇️
👤 ユーザー: 取り込み完了を確認
```

---

## 4. 各層の詳細解説

### 🖼️ Presentation Layer（プレゼンテーション層）

**責務**: 「ユーザーとの対話」

#### 主な機能
- HTML生成・レンダリング
- ユーザー入力の受付
- イベント処理（クリック、入力等）
- バリデーション（入力チェック）
- レスポンシブデザイン

#### 実例：DatabaseController.js
```javascript
class DatabaseController {
    constructor(dataStoreManager) {
        this.dataStoreManager = dataStoreManager;
        this.view = new DatabaseView();
        // 🎯 責務：画面制御のみ
    }

    showDatabase() {
        // ✅ 正しい責務：HTML描画
        const mainContent = document.getElementById('mainContent');
        mainContent.innerHTML = this.view.render();
        
        // ✅ 正しい責務：初期化
        this.initialize();
        this.loadTransactionsTab();
    }
    
    // ❌ 間違った責務例：ビジネスロジックを書いてはいけない
    // calculatePortfolioRisk() { /* Business Layerの責務 */ }
    // parseCsvFile() { /* Infrastructure Layerの責務 */ }
}
```

#### 学習ポイント
- **何を表示するか**ではなく**どう表示するか**に集中
- ビジネスロジックは下位層に委譲
- ユーザビリティ・アクセシビリティを重視

### 🧠 Application Layer（アプリケーション層）

**責務**: 「業務フローの編成」

#### 主な機能
- ユースケースの実装
- 複数のBusinessサービスの調整
- トランザクション境界の管理
- エラー処理・ログ出力

#### 実例：CsvImportService.js
```javascript
class CsvImportService {
    constructor({ assetRepository, sectorService }) {
        this.assetRepository = assetRepository;
        this.parser = new RakutenCsvParser();
        this.sectorService = sectorService;
        // 🎯 責務：複数サービスの調整
    }

    async parseAndPreview(file, csvType, progressCallback) {
        try {
            // 1️⃣ Infrastructure Layer活用
            const parseResult = await this.parser.parseCsvFile(file, csvType, progressCallback);
            
            if (!parseResult.success) {
                throw new Error(`CSV解析エラー: ${parseResult.error}`);
            }
            
            // 2️⃣ Business Layer活用（将来）
            // const enrichedData = this.sectorService.enrichWithSectors(parseResult.data);
            
            // 3️⃣ 結果の統合と返却
            return {
                transactions: parseResult.data || [],
                warnings: parseResult.debugInfo?.encodingSuccess ? [] : ['encoding-issues'],
                // ...
            };
            
        } catch (error) {
            // 🎯 責務：エラーハンドリング
            console.error('❌ CSV解析エラー:', error);
            return { transactions: [], warnings: ['parse-error'], error: error.message };
        }
    }
}
```

#### 学習ポイント
- **オーケストレーター**として機能
- 複雑な業務フローを管理
- 下位層の結果を統合して上位層に提供

### 💼 Business Layer（ビジネス層）

**責務**: 「ビジネスルール・計算」

#### 主な機能
- ドメインロジック（業界特有の計算）
- ビジネスルール（制約・検証）
- アルゴリズム（金融工学・統計）
- エンティティ管理

#### 実例：SectorService.js
```javascript
class SectorService {
    constructor() {
        // 🎯 責務：投資業界の専門知識
        this.sectorMaster = {
            JP: {
                '7203': { sector: 'トヨタ自動車', subSector: '自動車' },
                '6758': { sector: 'ソニーグループ', subSector: '電気機器' }
            },
            US: {
                'AAPL': { sector: 'Technology', subSector: 'Hardware' },
                'MSFT': { sector: 'Technology', subSector: 'Software' }
            }
        };
    }

    assignSectorToStock(stock) {
        // 🎯 責務：ビジネスルール実装
        const region = stock.region || 'JP';
        const identifier = stock.ticker || stock.code || '';
        
        // カスタム設定を優先（ビジネスルール）
        const customMapping = this.customSectorMappings[`${region}_${identifier}`];
        if (customMapping) {
            return { ...stock, sector: customMapping.sector, sectorSource: 'custom' };
        }

        // マスターデータ検索（業界標準）
        const masterData = this.sectorMaster[region];
        if (masterData && masterData[identifier]) {
            return { ...stock, sector: masterData[identifier].sector, sectorSource: 'master' };
        }

        // デフォルト値（ビジネスルール）
        return { ...stock, sector: 'その他', sectorSource: 'default' };
    }

    calculateConcentrationRisk(sectorAllocation) {
        // 🎯 責務：金融工学アルゴリズム（HHI指数）
        const hhi = sectorAllocation.reduce((sum, sector) => {
            return sum + Math.pow(sector.percentage, 2);
        }, 0);

        // 🎯 責務：リスク判定（投資業界の知識）
        let riskLevel = '低';
        if (hhi > 2500) riskLevel = '高';
        else if (hhi > 1500) riskLevel = '中';

        return {
            hhi,
            riskLevel,
            interpretation: hhi > 2500 ? 'セクター集中度が高いです' : 
                           hhi > 1500 ? '適度に分散されています' : 
                           '良好な分散投資です'
        };
    }
}
```

#### 学習ポイント
- **ドメイン知識**をコードで表現
- 技術的詳細は知らない（DBやUIは無関心）
- **不変のビジネスルール**を実装

### 🏪 Data Layer（データ層）

**責務**: 「データの永続化・取得」

#### 主な機能
- CRUD操作（Create, Read, Update, Delete）
- データストレージ抽象化
- トランザクション管理
- データマイグレーション

#### 実例：DataStoreManager.js
```javascript
class DataStoreManager {
    constructor() {
        // 🎯 責務：データ保存場所の管理
        this.STORAGE_KEYS = {
            mutualFunds: 'investment_mutual_funds',
            stocks: 'investment_stocks',
            cryptoAssets: 'investment_crypto_assets',
        };
    }

    save(key, data) {
        try {
            // 🎯 責務：データ永続化の技術的詳細
            const serialized = JSON.stringify(data);
            localStorage.setItem(key, serialized);
            return true;
        } catch (error) {
            // 🎯 責務：ストレージエラー処理
            if (error.name === 'QuotaExceededError') {
                console.error('保存容量不足');
            }
            return false;
        }
    }

    load(key) {
        try {
            // 🎯 責務：データ復元の技術的詳細
            const stored = localStorage.getItem(key);
            return stored ? JSON.parse(stored) : null;
        } catch (error) {
            console.error('データ読み込みエラー:', error);
            return null;
        }
    }

    // 🎯 責務：データマイグレーション
    _migrateFundData(fund) {
        // 古いデータ形式から新しい形式への変換
        if (!fund.version || fund.version < 2) {
            return {
                ...fund,
                version: 2,
                updatedAt: new Date().toISOString()
            };
        }
        return fund;
    }
}
```

#### 学習ポイント
- **ストレージの技術的詳細**を隠蔽
- 上位層は「保存」「取得」という抽象的な操作のみ知る
- データ形式変更時の影響を最小化

### 🔌 Infrastructure Layer（基盤層）

**責務**: 「外部システム連携・技術的機能」

#### 主な機能
- 外部API呼び出し
- ファイル解析・変換
- 技術的ユーティリティ
- サードパーティライブラリ連携

#### 実例：RakutenCsvParser.js
```javascript
class RakutenCsvParser {
    async readCsvFileWithProperEncoding(file) {
        const encodings = ['Shift_JIS', 'UTF-8', 'ISO-8859-1'];
        
        for (const encoding of encodings) {
            try {
                // 🎯 責務：技術的複雑さの隠蔽
                const text = await new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (event) => resolve(event.target.result);
                    reader.onerror = () => reject(new Error(`${encoding}での読み込みに失敗`));
                    reader.readAsText(file, encoding);
                });
                
                // 🎯 責務：エンコーディング検証
                if (this.containsValidJapanese(text)) {
                    return text;
                }
                
            } catch (error) {
                continue;
            }
        }
        
        throw new Error('すべてのエンコーディングでの読み込みに失敗しました');
    }

    convertSingleRow(row, csvType) {
        // 🎯 責務：楽天証券固有のデータ形式変換
        switch (csvType) {
            case 'JP':
                return {
                    date: this.parseDate(row['約定日']),
                    name: row['銘柄名'] || '',
                    code: row['銘柄コード'] || '',
                    quantity: this.parseQuantity(row['数量［株］'] || '0'),
                    unitPrice: this.parseAmount(row['単価［円］'] || '0'),
                    // ...
                };
            // ...
        }
    }
}
```

#### 学習ポイント
- **外部の複雑さ**をシステム内部に持ち込まない
- 技術変更（CSV形式変更等）の影響を局所化
- **アダプターパターン**で外部形式を内部形式に変換

---

## 5. 依存関係のルール

### 📐 基本原則

```
🚫 禁止されている依存関係
┌─────────────────┐
│   UI Layer      │ ⬅️ ❌ Application Layer
├─────────────────┤    ❌ Business Layer  
│ Application     │ ⬅️ ❌ Data Layer
├─────────────────┤    ❌ Infrastructure Layer
│   Business      │
├─────────────────┤
│     Data        │
├─────────────────┤
│ Infrastructure  │
└─────────────────┘

✅ 正しい依存関係  
┌─────────────────┐
│   UI Layer      │ ➡️ Application Layer のみ
├─────────────────┤
│ Application     │ ➡️ Business + Data Layer のみ
├─────────────────┤
│   Business      │ ➡️ (基本的に他層に依存しない)
├─────────────────┤
│     Data        │ ➡️ Infrastructure Layer のみ
├─────────────────┤
│ Infrastructure  │ ➡️ (最下位層・他層に依存しない)
└─────────────────┘
```

### 🔍 実際のコード例

#### ❌ **悪い例：依存関係違反**

```javascript
// Infrastructure LayerがBusiness Layerに依存（違反！）
class RakutenCsvParser {
    convertRow(row) {
        const data = this.parseBasicData(row);
        
        // ❌ Infrastructure層でビジネスロジックを実行
        const sectorService = new SectorService();
        data.sector = sectorService.assignSector(data);
        
        return data;
    }
}

// Business LayerがUI Layerを知っている（違反！）
class SectorService {
    calculateRisk(portfolio) {
        const risk = this.computeHHI(portfolio);
        
        // ❌ Business層でUI操作
        document.getElementById('riskDisplay').textContent = risk.level;
        
        return risk;
    }
}
```

#### ✅ **良い例：正しい依存関係**

```javascript
// Infrastructure Layer：技術的機能のみ
class RakutenCsvParser {
    convertRow(row) {
        // ✅ データ変換のみ（ビジネスロジックなし）
        return {
            date: this.parseDate(row['約定日']),
            name: row['銘柄名'] || '',
            code: row['銘柄コード'] || '',
            quantity: this.parseQuantity(row['数量［株］'] || '0')
        };
    }
}

// Business Layer：ビジネスロジックのみ
class SectorService {
    calculateRisk(portfolio) {
        // ✅ 計算のみ（UI操作なし）
        const hhi = portfolio.reduce((sum, asset) => 
            sum + Math.pow(asset.percentage, 2), 0);
        
        return {
            hhi,
            level: hhi > 2500 ? 'high' : hhi > 1500 ? 'medium' : 'low'
        };
    }
}

// Application Layer：調整役
class PortfolioService {
    async updatePortfolioWithRisk(csvFile) {
        // ✅ 下位層のサービスを組み合わせ
        const data = await this.csvParser.parse(csvFile);      // Infrastructure
        const withSectors = this.sectorService.assign(data);   // Business
        const withRisk = this.sectorService.calculateRisk(withSectors); // Business
        
        return { portfolio: withSectors, risk: withRisk };
    }
}

// UI Layer：表示とイベント処理のみ
class PortfolioController {
    async importCsv(file) {
        // ✅ Application Layerに処理を委譲
        const result = await this.portfolioService.updatePortfolioWithRisk(file);
        
        // ✅ 表示のみ
        this.view.displayPortfolio(result.portfolio);
        this.view.displayRisk(result.risk);
    }
}
```

### 🛡️ 依存関係チェック方法

#### 1. **インポート文の確認**
```javascript
// ❌ 下位層が上位層をインポート
// Infrastructure LayerでApplication Layerをインポート
import { CsvImportService } from '../../services/CsvImportService.js'; // 違反！

// ✅ 上位層が下位層をインポート
// Application LayerでInfrastructure Layerをインポート
import { RakutenCsvParser } from '../infrastructure/parsers/RakutenCsvParser.js'; // 正しい
```

#### 2. **new演算子の確認**
```javascript
// ❌ 下位層で上位層のインスタンス作成
class SectorService {
    updateUI(data) {
        const controller = new DashboardController(); // 違反！
        controller.update(data);
    }
}

// ✅ 上位層で下位層のインスタンス作成
class DashboardController {
    constructor() {
        this.sectorService = new SectorService(); // 正しい
    }
}
```

#### 3. **メソッド呼び出しの確認**
```javascript
// ❌ 循環依存
class ServiceA {
    method() {
        const serviceB = new ServiceB();
        serviceB.callServiceA(); // ServiceB内でServiceAを呼ぶ
    }
}

class ServiceB {
    callServiceA() {
        const serviceA = new ServiceA(); // 循環依存！
        serviceA.method();
    }
}
```

---

## 6. 実践演習

### 🎯 演習1：層の識別

以下のコードはどの層に属すべきでしょうか？

```javascript
// A. ユーザーのクリックイベントを処理
function handlePortfolioClick(event) {
    const portfolioId = event.target.dataset.portfolioId;
    showPortfolioDetails(portfolioId);
}

// B. 投資リスクのHHI指数を計算
function calculateHHIIndex(allocations) {
    return allocations.reduce((sum, allocation) => {
        return sum + Math.pow(allocation.percentage, 2);
    }, 0);
}

// C. LocalStorageからデータを読み込み
function loadPortfolioData(portfolioId) {
    const key = `portfolio_${portfolioId}`;
    const data = localStorage.getItem(key);
    return data ? JSON.parse(data) : null;
}

// D. 楽天証券CSVの1行を解析
function parseRakutenCsvRow(csvRow) {
    return {
        date: csvRow['約定日'],
        stock: csvRow['銘柄名'],
        quantity: parseInt(csvRow['数量［株］'])
    };
}

// E. 複数のサービスを組み合わせてポートフォリオ分析を実行
async function analyzePortfolio(csvFile) {
    const data = await csvParser.parse(csvFile);
    const sectors = sectorService.assign(data);
    const risk = riskService.calculate(sectors);
    return { data, sectors, risk };
}
```

<details>
<summary>🔍 解答を見る</summary>

- **A. Presentation Layer** - ユーザーイベント処理
- **B. Business Layer** - 投資のビジネスロジック（HHI計算）
- **C. Data Layer** - データの永続化・取得
- **D. Infrastructure Layer** - 外部データ形式の解析
- **E. Application Layer** - 複数サービスの調整

</details>

### 🎯 演習2：依存関係の修正

以下のコードの依存関係違反を修正してください：

```javascript
// 問題のあるコード
class CsvParser {
    parseFile(file) {
        const data = this.extractData(file);
        
        // 🚨 Infrastructure LayerでBusiness Layerを使用
        const sectorService = new SectorService();
        data.forEach(row => {
            row.sector = sectorService.assignSector(row);
        });
        
        // 🚨 Infrastructure LayerでData Layerを使用
        const repository = new AssetRepository();
        repository.saveAll(data);
        
        return data;
    }
}
```

<details>
<summary>🔍 解答を見る</summary>

```javascript
// 修正版：依存関係を正しく分離

// Infrastructure Layer：解析のみ
class CsvParser {
    parseFile(file) {
        // ✅ データ抽出のみ（他層に依存しない）
        return this.extractData(file);
    }
}

// Application Layer：調整役
class CsvImportService {
    constructor() {
        this.csvParser = new CsvParser();       // Infrastructure
        this.sectorService = new SectorService(); // Business
        this.repository = new AssetRepository();  // Data
    }
    
    async importCsv(file) {
        // ✅ 上位層が下位層を組み合わせ
        const data = this.csvParser.parseFile(file);
        
        const withSectors = data.map(row => 
            this.sectorService.assignSector(row)
        );
        
        await this.repository.saveAll(withSectors);
        
        return withSectors;
    }
}
```

</details>

### 🎯 演習3：新機能の設計

「ポートフォリオのパフォーマンス分析」機能を追加する場合、どの層にどの責務を配置しますか？

**要件:**
- 過去のデータから年率リターンを計算
- ベンチマーク（日経平均、S&P500）と比較
- 結果をグラフで表示

<details>
<summary>🔍 解答例を見る</summary>

```javascript
// Infrastructure Layer：外部データ取得
class BenchmarkDataProvider {
    async fetchNikkeiData(startDate, endDate) {
        // 外部APIから日経平均データを取得
    }
    
    async fetchSP500Data(startDate, endDate) {
        // 外部APIからS&P500データを取得
    }
}

// Business Layer：パフォーマンス計算
class PerformanceAnalyzer {
    calculateAnnualReturn(priceData) {
        // 年率リターン計算の投資アルゴリズム
    }
    
    compareWithBenchmark(portfolioReturn, benchmarkReturn) {
        // ベンチマーク比較のビジネスロジック
    }
    
    calculateVolatility(priceData) {
        // ボラティリティ計算
    }
}

// Data Layer：履歴データ管理
class PerformanceRepository {
    savePerformanceHistory(data) {
        // パフォーマンス履歴の保存
    }
    
    getPortfolioHistory(portfolioId, period) {
        // 過去データの取得
    }
}

// Application Layer：機能の編成
class PerformanceService {
    constructor() {
        this.analyzer = new PerformanceAnalyzer();
        this.dataProvider = new BenchmarkDataProvider();
        this.repository = new PerformanceRepository();
    }
    
    async analyzePerformance(portfolioId, period) {
        // 1. データ取得
        const portfolioData = await this.repository.getPortfolioHistory(portfolioId, period);
        const benchmarkData = await this.dataProvider.fetchNikkeiData(period.start, period.end);
        
        // 2. 計算
        const portfolioReturn = this.analyzer.calculateAnnualReturn(portfolioData);
        const benchmarkReturn = this.analyzer.calculateAnnualReturn(benchmarkData);
        
        // 3. 比較
        const comparison = this.analyzer.compareWithBenchmark(portfolioReturn, benchmarkReturn);
        
        return { portfolioReturn, benchmarkReturn, comparison };
    }
}

// Presentation Layer：グラフ表示
class PerformanceChart {
    displayPerformanceComparison(data) {
        // Chart.jsを使ってグラフを描画
    }
}

class PerformanceController {
    async showPerformanceAnalysis(portfolioId) {
        const result = await this.performanceService.analyzePerformance(portfolioId, { period: '1year' });
        this.chart.displayPerformanceComparison(result);
    }
}
```

</details>

---

## 7. よくある間違いと対策

### 🚨 間違い1：神クラス（God Class）

**問題:**
```javascript
// ❌ すべてを1つのクラスで処理
class PortfolioManager {
    // UI処理
    displayPortfolio() { /* ... */ }
    handleClick() { /* ... */ }
    
    // ビジネスロジック
    calculateRisk() { /* ... */ }
    assignSectors() { /* ... */ }
    
    // データ操作
    saveData() { /* ... */ }
    loadData() { /* ... */ }
    
    // 外部連携
    parseCsv() { /* ... */ }
    callAPI() { /* ... */ }
}
```

**解決策:**
```javascript
// ✅ 責務を分離
class PortfolioController {        // Presentation
    displayPortfolio() { /* ... */ }
}

class PortfolioAnalyzer {          // Business
    calculateRisk() { /* ... */ }
}

class PortfolioRepository {        // Data
    saveData() { /* ... */ }
}

class CsvParser {                  // Infrastructure
    parseCsv() { /* ... */ }
}
```

### 🚨 間違い2：循環依存

**問題:**
```javascript
// ❌ ServiceAとServiceBが互いに依存
class ServiceA {
    constructor() {
        this.serviceB = new ServiceB(); // ServiceBを依存
    }
    
    methodA() {
        return this.serviceB.methodB();
    }
}

class ServiceB {
    constructor() {
        this.serviceA = new ServiceA(); // ServiceAを依存（循環！）
    }
    
    methodB() {
        return this.serviceA.methodA();
    }
}
```

**解決策:**
```javascript
// ✅ 共通機能を下位層に抽出
class SharedService {              // 下位層
    sharedMethod() { /* ... */ }
}

class ServiceA {                   // 上位層
    constructor() {
        this.sharedService = new SharedService();
    }
    
    methodA() {
        return this.sharedService.sharedMethod();
    }
}

class ServiceB {                   // 上位層
    constructor() {
        this.sharedService = new SharedService();
    }
    
    methodB() {
        return this.sharedService.sharedMethod();
    }
}
```

### 🚨 間違い3：層の責務違反

**問題:**
```javascript
// ❌ Business LayerでUI操作
class RiskCalculator {
    calculateRisk(portfolio) {
        const risk = this.computeHHI(portfolio);
        
        // Business LayerでDOM操作（違反！）
        document.getElementById('risk-display').textContent = risk.level;
        alert(`リスクレベル: ${risk.level}`);
        
        return risk;
    }
}
```

**解決策:**
```javascript
// ✅ Business Layerは計算のみ
class RiskCalculator {
    calculateRisk(portfolio) {
        const hhi = this.computeHHI(portfolio);
        
        // 計算結果のみ返却（UI操作なし）
        return {
            hhi,
            level: this.determineRiskLevel(hhi),
            recommendation: this.getRecommendation(hhi)
        };
    }
}

// ✅ Presentation Layerで表示
class RiskDisplayController {
    updateRiskDisplay(risk) {
        document.getElementById('risk-display').textContent = risk.level;
        
        if (risk.level === 'high') {
            this.showRiskWarning(risk.recommendation);
        }
    }
}
```

### 🚨 間違い4：硬直した設計

**問題:**
```javascript
// ❌ 具象クラスに直接依存
class PortfolioService {
    constructor() {
        this.storage = new LocalStorageManager(); // 具象クラスに依存
    }
    
    save(data) {
        return this.storage.save(data); // LocalStorage専用
    }
}
```

**解決策:**
```javascript
// ✅ 抽象（インターフェース）に依存
interface StorageInterface {
    save(data): boolean;
    load(key): any;
}

class LocalStorageManager implements StorageInterface {
    save(data) { /* LocalStorage実装 */ }
    load(key) { /* LocalStorage実装 */ }
}

class IndexedDBManager implements StorageInterface {
    save(data) { /* IndexedDB実装 */ }
    load(key) { /* IndexedDB実装 */ }
}

class PortfolioService {
    constructor(storage: StorageInterface) {
        this.storage = storage; // 抽象に依存
    }
    
    save(data) {
        return this.storage.save(data); // 実装を知らない
    }
}

// 使用時に具象クラスを注入
const portfolioService = new PortfolioService(new LocalStorageManager());
```

---

## 8. 発展的なトピック

### 🏗️ SOLID原則との関係

レイヤードアーキテクチャは、SOLID原則を実践する手法でもあります：

#### **S - Single Responsibility Principle（単一責務原則）**
```javascript
// ✅ 各層が単一の責務を持つ
class CsvParser {          // 責務：CSV解析のみ
class SectorService {      // 責務：セクター分析のみ
class DataRepository {     // 責務：データ永続化のみ
```

#### **O - Open/Closed Principle（開放閉鎖原則）**
```javascript
// ✅ 新機能追加時は拡張（新クラス追加）、既存コード変更不要
class NewCsvFormat extends CsvParser {
    // 既存のCsvParserを変更せず、新形式をサポート
}
```

#### **L - Liskov Substitution Principle（リスコフの置換原則）**
```javascript
// ✅ 同一層の異なる実装を置換可能
const storage1 = new LocalStorageRepository();
const storage2 = new IndexedDBRepository();
// どちらも同じインターフェースで使用可能
```

#### **I - Interface Segregation Principle（インターフェース分離原則）**
```javascript
// ✅ 各層が必要な機能のみを要求
interface CsvParserInterface {
    parse(file): TransactionData[];  // 必要最小限
}
```

#### **D - Dependency Inversion Principle（依存性逆転原則）**
```javascript
// ✅ 上位層は抽象に依存、具象に依存しない
class PortfolioService {
    constructor(parser: CsvParserInterface) { // 抽象に依存
        this.parser = parser;
    }
}
```

### 🔄 他のアーキテクチャパターンとの比較

#### **MVC vs レイヤードアーキテクチャ**

```
MVC（Model-View-Controller）
┌─────────┐    ┌─────────┐
│  View   │◄──►│Controller│
└─────────┘    └─────────┘
      ▲             │
      │             ▼
      └─────►┌─────────┐
             │  Model  │
             └─────────┘

レイヤードアーキテクチャ
┌─────────────┐
│Presentation │ ← MVCのView + Controller
├─────────────┤
│Application  │ ← 業務フロー調整
├─────────────┤
│  Business   │ ← MVCのModel（一部）
├─────────────┤
│    Data     │ ← MVCのModel（一部）
├─────────────┤
│Infrastructure│ ← 技術基盤
└─────────────┘
```

#### **Clean Architecture**
```javascript
// Uncle Bob（Robert C. Martin）のClean Architecture
// 依存関係が内側（ビジネスルール）に向かう
┌─────────────────────────────────┐
│        UI/Web/Framework         │ ← Framework & Drivers
├─────────────────────────────────┤
│     Controllers/Presenters      │ ← Interface Adapters
├─────────────────────────────────┤
│        Use Cases                │ ← Application Business Rules
├─────────────────────────────────┤
│         Entities                │ ← Enterprise Business Rules
└─────────────────────────────────┘
```

### 🧪 テスト戦略

#### **層ごとのテスト手法**

```javascript
// Infrastructure Layer：技術的機能テスト
describe('RakutenCsvParser', () => {
    it('should parse JP stock CSV correctly', async () => {
        const parser = new RakutenCsvParser();
        const mockFile = createMockCsvFile('JP stock data');
        
        const result = await parser.parseCsvFile(mockFile, 'JP');
        
        expect(result.success).toBe(true);
        expect(result.data[0].name).toBe('トヨタ自動車');
    });
});

// Business Layer：ビジネスロジックテスト
describe('SectorService', () => {
    it('should calculate HHI correctly', () => {
        const service = new SectorService();
        const allocation = [
            { sector: 'Technology', percentage: 60 },
            { sector: 'Finance', percentage: 40 }
        ];
        
        const risk = service.calculateConcentrationRisk(allocation);
        
        expect(risk.hhi).toBe(5200); // 60² + 40² = 3600 + 1600
        expect(risk.riskLevel).toBe('高');
    });
});

// Application Layer：統合テスト
describe('CsvImportService', () => {
    it('should import CSV with sector assignment', async () => {
        const mockRepository = {
            getAllAssets: jest.fn().mockResolvedValue([]),
            addAsset: jest.fn().mockResolvedValue({ id: 'test_123' })
        };
        
        const service = new CsvImportService({ assetRepository: mockRepository });
        const transactions = [{ symbol: 'AAPL', name: 'Apple Inc.' }];
        
        const result = await service.importTransactions(transactions);
        
        expect(result.imported).toBe(1);
        expect(mockRepository.addAsset).toHaveBeenCalled();
    });
});
```

### 🚀 マイクロサービスへの発展

```javascript
// レイヤードアーキテクチャ → マイクロサービス移行例

// 従来：1つのアプリケーション内の層
class PortfolioService {
    constructor() {
        this.csvParser = new RakutenCsvParser();      // Infrastructure
        this.sectorService = new SectorService();      // Business
        this.repository = new PortfolioRepository();   // Data
    }
}

// 移行後：独立したマイクロサービス
class PortfolioService {
    constructor() {
        this.csvParserAPI = new CsvParserMicroservice('http://csv-parser-service');
        this.sectorAPI = new SectorMicroservice('http://sector-service');
        this.repository = new PortfolioRepository(); // 一部は残る
    }
    
    async importCsv(file) {
        const parsed = await this.csvParserAPI.parse(file);      // 外部サービス
        const withSectors = await this.sectorAPI.assignSectors(parsed); // 外部サービス
        return await this.repository.save(withSectors);         // ローカル
    }
}
```

---

## 🎯 まとめ

### 📚 学習のポイント

1. **責務の分離**：各層が明確な役割を持つ
2. **依存関係管理**：上位層→下位層の一方向のみ
3. **抽象化**：技術的詳細を隠蔽し、ビジネスロジックに集中
4. **テスタビリティ**：各層を独立してテスト可能
5. **保守性**：変更の影響を局所化

### 🛠️ 実践での活用

- **設計時**：新機能をどの層に配置するか判断
- **レビュー時**：依存関係違反がないかチェック
- **リファクタリング時**：責務の適切な分離
- **テスト時**：層ごとの独立したテスト

### 🔄 継続的な改善

1. **定期的なアーキテクチャレビュー**
2. **依存関係の可視化**
3. **新技術との適応**
4. **チーム内での知識共有**

---

**学習完了おめでとうございます！** 🎉

レイヤードアーキテクチャは、ソフトウェア開発における重要な設計パターンです。今回の投資ダッシュボード開発を通じて、理論だけでなく実践的な理解も深まったかと思います。

このアーキテクチャの知識は、今後より大規模で複雑なシステムを設計する際にも活用できます。ぜひ継続的に実践を積み重ねて、さらなるスキルアップを目指してください！