# データ層とインフラ層の違い - 具体例で学ぶレイヤードアーキテクチャ

**作成日**: 2025年9月21日  
**対象**: レイヤードアーキテクチャ学習者  
**プロジェクト**: 投資ダッシュボード v2  
**目的**: Data Layer と Infrastructure Layer の違いを実例で理解

---

## 🤔 よくある混乱ポイント

レイヤードアーキテクチャを学ぶ際、**Data Layer（データ層）** と **Infrastructure Layer（インフラ層）** の違いが最も理解しにくいポイントです。

**どちらも「データを扱う」層なので、区別が難しい！**

この文書では、現在の投資ダッシュボード v2 プロジェクトの実際のコードを使って、この違いを具体的に解説します。

---

## 🏗️ レイヤー構成の再確認

まず、私たちのプロジェクトのレイヤー構成を見てみましょう：

```
投資ダッシュボード v2 - 5層構造
┌─────────────────────────────────────┐
│  🖼️  Presentation Layer            │  ← UI・ユーザー操作
├─────────────────────────────────────┤
│  🧠  Application Layer              │  ← ビジネスフロー調整
├─────────────────────────────────────┤
│  💼  Business Layer                 │  ← ビジネスロジック・計算
├─────────────────────────────────────┤
│  🏪  Data Layer                     │  ← データ管理・永続化 ⭐
├─────────────────────────────────────┤
│  🔌  Infrastructure Layer           │  ← 外部システム連携 ⭐
└─────────────────────────────────────┘
```

**重要**: ⭐マークの2つの層が今回の焦点です！

---

## 🎯 Data Layer（データ層）の責務

### 📋 Data Layerとは？
**「アプリケーション内部のデータ管理を担当する層」**

### 🔍 具体例：DataStoreManager.js

```javascript
// ファイル: src/data/managers/DataStoreManager.js
class DataStoreManager {
    // 👆 データ層の典型例

    /**
     * 資産データをLocalStorageに保存
     * 💡 ポイント: アプリ内部のデータを「どこに」「どう保存するか」
     */
    saveAssets(assets) {
        try {
            const serialized = JSON.stringify(assets);
            localStorage.setItem('investment_assets', serialized);
            // ✅ 内部データの永続化を担当
        } catch (error) {
            throw new Error('資産データ保存に失敗しました');
        }
    }

    /**
     * 保存された資産データを取得
     * 💡 ポイント: アプリ内部で使うデータの「取得方法」を定義
     */
    loadAssets() {
        try {
            const saved = localStorage.getItem('investment_assets');
            return saved ? JSON.parse(saved) : [];
            // ✅ 内部データの読み取りを担当
        } catch (error) {
            console.error('資産データ読み込みエラー:', error);
            return [];
        }
    }

    /**
     * データの整合性チェック
     * 💡 ポイント: アプリ内部データの「品質管理」
     */
    validateAssetData(asset) {
        if (!asset.name || !asset.currentValue) {
            throw new Error('必須項目が不足しています');
        }
        // ✅ 内部データの品質保証
    }
}
```

### 🎯 Data Layerの特徴
1. **内部データ中心**: アプリ内で使うデータの管理
2. **永続化**: データの保存・読み込み
3. **CRUD操作**: Create・Read・Update・Delete
4. **データ整合性**: データの品質保証
5. **ストレージ抽象化**: LocalStorage・IndexedDB・SQLiteなど

---

## 🔌 Infrastructure Layer（インフラ層）の責務

### 📋 Infrastructure Layerとは？
**「外部システムとの連携・技術的複雑さを隠蔽する層」**

### 🔍 具体例：RakutenCsvParser.js

```javascript
// ファイル: src/infrastructure/parsers/RakutenCsvParser.js
class RakutenCsvParser {
    // 👆 インフラ層の典型例

    /**
     * 楽天証券CSVファイルを解析
     * 💡 ポイント: 「外部形式」のデータを「内部形式」に変換
     */
    async parseCsvFile(file, csvType, progressCallback) {
        // ✅ 外部システム（楽天証券）のデータ形式を扱う
        
        // 1. 外部ファイルの技術的問題を解決
        const csvText = await this.readCsvFileWithProperEncoding(file);
        // 👆 Shift-JIS問題など、技術的複雑さを隠蔽
        
        // 2. 外部ライブラリの使用
        const parseResult = Papa.parse(csvText, {
            header: true,
            skipEmptyLines: true
        });
        // 👆 Papa Parse という外部ライブラリに依存
        
        // 3. 外部形式 → 内部標準形式に変換
        const convertedData = parseResult.data.map(row => 
            this.convertSingleRow(row, csvType)
        );
        // 👆 楽天形式 → アプリ標準形式への変換
        
        return {
            success: true,
            data: convertedData,  // ← Data Layerが扱える形式
            // ...メタデータ
        };
    }

    /**
     * Shift-JIS文字エンコーディング問題を解決
     * 💡 ポイント: 技術的な複雑さを完全に隠蔽
     */
    async readCsvFileWithProperEncoding(file) {
        const encodings = ['Shift_JIS', 'UTF-8', 'ISO-8859-1'];
        
        for (const encoding of encodings) {
            try {
                // ✅ 外部ファイルの技術的制約に対応
                const reader = new FileReader();
                // ...複雑な処理
                return text;
            } catch (error) {
                continue; // 次のエンコーディングを試行
            }
        }
        // 👆 上位層はこの複雑さを知る必要がない
    }
}
```

### 🎯 Infrastructure Layerの特徴
1. **外部システム連携**: 外部APIやファイル形式への対応
2. **技術的複雑さ隠蔽**: エンコーディング・プロトコル・ライブラリ
3. **形式変換**: 外部形式 ↔ 内部形式
4. **外部依存管理**: 外部ライブラリ・API・サービス
5. **技術的エラー処理**: ネットワーク・ファイル・パース系エラー

---

## 🔄 実際の連携例で理解する

### 📊 CSV取り込み機能での連携

```javascript
// Application Layer: CsvImportService.js
class CsvImportService {
    async parseAndPreview(file, csvType, progressCallback) {
        
        // 🔌 Infrastructure Layer を使用
        const parseResult = await this.parser.parseCsvFile(file, csvType, progressCallback);
        // 👆 外部ファイル（楽天CSV）→ 内部形式への変換
        
        // 🏪 Data Layer を使用（将来）
        // await this.assetRepository.save(parseResult.data);
        // 👆 内部形式データの永続化
        
        return {
            transactions: parseResult.data,  // ← 標準化されたデータ
            warnings: parseResult.warnings
        };
    }
}
```

### 🎯 この例でわかること

1. **Infrastructure Layer**:
   - 楽天証券の**外部CSV形式**を扱う
   - Shift-JIS**技術的問題**を解決
   - **Papa Parse ライブラリ**を使用
   - **アプリ標準形式**に変換

2. **Data Layer**:
   - 変換された**内部データ**を受け取る
   - **LocalStorage**に保存
   - **アプリ内**でのCRUD操作
   - **データ整合性**をチェック

---

## 💡 判断基準：どちらの層に属するか？

### 🤔 迷った時の判断基準

| 観点 | Data Layer | Infrastructure Layer |
|------|------------|---------------------|
| **データの出所** | アプリ内部で生成・管理 | 外部システムから取得 |
| **技術的複雑さ** | ビジネス観点の処理 | 技術的制約・互換性 |
| **依存関係** | アプリ内コンポーネント | 外部ライブラリ・API |
| **変更理由** | ビジネス要件変更 | 技術仕様・外部システム変更 |
| **テストの観点** | データ正確性・整合性 | 外部連携・エラー処理 |

### 📝 具体的な判断例

```javascript
// ❓ これはどちらの層？

// 例1: ポートフォリオデータをJSONで保存
savePortfolio(portfolio) {
    localStorage.setItem('portfolio', JSON.stringify(portfolio));
}
// ✅ Data Layer: 内部データの永続化

// 例2: Yahoo Finance APIから株価取得
async fetchStockPrice(symbol) {
    const response = await fetch(`https://api.yahoo.com/v1/stock/${symbol}`);
    return response.json();
}
// ✅ Infrastructure Layer: 外部API連携

// 例3: CSVファイルをパース
parseCsv(csvContent) {
    return Papa.parse(csvContent, { header: true });
}
// ✅ Infrastructure Layer: 外部ライブラリ使用

// 例4: アプリ内データの検索
findAssetsByType(assets, type) {
    return assets.filter(asset => asset.type === type);
}
// ✅ Data Layer: 内部データ操作

// 例5: 楽天証券API認証
async authenticateRakuten(credentials) {
    // 外部認証プロトコル処理...
}
// ✅ Infrastructure Layer: 外部システム認証
```

---

## 🏗️ 設計上の重要な原則

### 1️⃣ **依存関係の方向性**

```
✅ 正しい依存関係
Application Layer
    ↓ 
Data Layer ← Infrastructure Layer
    ↓           ↓
 LocalStorage  External API
```

```
❌ 間違った依存関係  
Infrastructure Layer → Data Layer  
（インフラ層がデータ層を直接操作）
```

### 2️⃣ **責務の明確化**

```javascript
// ✅ 良い例：責務が明確
class RakutenCsvParser {  // Infrastructure Layer
    // 外部CSV解析のみに特化
    async parseCsvFile(file) { /* ... */ }
}

class AssetRepository {   // Data Layer  
    // 内部データ管理のみに特化
    async saveAssets(assets) { /* ... */ }
}

// ❌ 悪い例：責務が混在
class DataManager {
    async parseCsvAndSave(file) {
        // 外部CSV解析 + 内部データ保存が混在
        const data = Papa.parse(file);  // ← Infrastructure Layer の仕事
        localStorage.setItem('data', data);  // ← Data Layer の仕事
    }
}
```

### 3️⃣ **抽象化レベルの一貫性**

```javascript
// Data Layer: ビジネス観点の抽象化
class AssetRepository {
    async saveAssets(assets) { /* ビジネス的な保存処理 */ }
    async findAssetsByType(type) { /* ビジネス的な検索処理 */ }
}

// Infrastructure Layer: 技術観点の抽象化  
class CsvParser {
    async parseFile(file) { /* 技術的なファイル解析 */ }
    async handleEncoding(file) { /* 技術的なエンコーディング処理 */ }
}
```

---

## 🧪 実践演習

### 🔍 演習1：層の分類

以下の機能はどちらの層に属するでしょうか？

```javascript
// A. ユーザーの投資データをIndexedDBに保存
// B. SBI証券のAPIから取引履歴を取得  
// C. ポートフォリオデータの重複を除去
// D. 楽天証券CSVの文字化け修正
// E. 保存されたデータのバックアップ作成
```

**解答**:
- A. Data Layer（内部データの永続化）
- B. Infrastructure Layer（外部API連携）
- C. Data Layer（内部データの品質管理）
- D. Infrastructure Layer（外部形式の技術的問題解決）
- E. Data Layer（内部データの管理業務）

### 🔍 演習2：設計改善

```javascript
// 現在のコード（問題あり）
class DataProcessor {
    async processInvestmentData(csvFile) {
        // 外部CSVファイル読み込み
        const text = await this.readShiftJISFile(csvFile);
        
        // CSV解析
        const parsed = Papa.parse(text);
        
        // データ変換
        const converted = parsed.data.map(row => ({
            name: row['銘柄名'],
            value: Number(row['評価額'])
        }));
        
        // データ保存
        localStorage.setItem('assets', JSON.stringify(converted));
        
        return converted;
    }
}
```

**問題点**: Infrastructure Layer と Data Layer の責務が混在

**改善案**:
```javascript
// Infrastructure Layer
class CsvFileParser {
    async parseFile(file) {
        const text = await this.readShiftJISFile(file);
        return Papa.parse(text);
    }
}

// Data Layer
class AssetRepository {
    async saveAssets(assets) {
        localStorage.setItem('assets', JSON.stringify(assets));
    }
}

// Application Layer  
class DataImportService {
    async importCsvData(file) {
        const parsed = await this.csvParser.parseFile(file);
        const assets = this.convertToAssets(parsed.data);
        await this.assetRepository.saveAssets(assets);
        return assets;
    }
}
```

---

## 📚 まとめ

### 🎯 Data Layer と Infrastructure Layer の本質的違い

| 観点 | Data Layer | Infrastructure Layer |
|------|------------|---------------------|
| **中心概念** | アプリ内データの生命周期管理 | 外部世界との技術的橋渡し |
| **抽象化対象** | データの構造・整合性・永続化 | 技術的複雑さ・外部依存 |
| **変更駆動力** | ビジネス要件・データモデル変更 | 技術進歩・外部システム変更 |
| **テストの焦点** | データ正確性・ビジネスルール | 外部連携・技術的互換性 |

### 💡 覚えておくべきポイント

1. **Data Layer**: 「アプリの中でデータをどう管理するか」
2. **Infrastructure Layer**: 「外の世界とどう繋がるか」
3. **判断迷子**: 「これは技術的問題？ビジネス的問題？」で判断
4. **依存関係**: どちらも上位層（Application Layer）に依存
5. **協調**: 互いに独立しつつ、Application Layerで協調

### 🚀 次のステップ

1. **実装練習**: 既存コードの層分離リファクタリング
2. **設計演習**: 新機能実装時の層責務設計
3. **深化学習**: DDD（Domain Driven Design）でのRepository パターン
4. **応用**: CQRS（Command Query Responsibility Segregation）パターン

---

**参考文献**:
- 『Clean Architecture』 Robert C. Martin
- 『Domain-Driven Design』 Eric Evans  
- 『エンタープライズアプリケーションアーキテクチャパターン』 Martin Fowler

**作成者**: Claude Code  
**学習対象**: 投資ダッシュボード v2 開発チーム  
**更新日**: 2025年9月21日

---

> 💡 **学習のコツ**: 理論だけでなく、実際のコードを書いて「どちらの層に属するか？」を常に意識することで、自然と適切な設計判断ができるようになります。迷った時は「技術的？ビジネス的？」で判断しましょう！