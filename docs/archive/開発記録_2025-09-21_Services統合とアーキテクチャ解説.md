# 投資ダッシュボード v2 - 開発記録 & レイヤードアーキテクチャ解説

**開発日**: 2025年9月21日  
**開発時間**: 約2時間  
**フェーズ**: Phase 1.2 Services統合実装完了  
**作成者**: Claude Code + ユーザー

---

## 📚 レイヤードアーキテクチャとは？

### 🏗️ アーキテクチャの基本概念

**レイヤードアーキテクチャ（層化アーキテクチャ）**は、ソフトウェアを複数の「層（レイヤー）」に分割して設計する手法です。各層は明確な**責務**を持ち、上位層は下位層にのみ依存するという**依存関係のルール**があります。

### 🎯 なぜレイヤードアーキテクチャを使うのか？

1. **関心の分離** - 各層が特定の責務に集中
2. **テスタビリティ** - 層ごとに独立してテスト可能
3. **保守性** - 変更の影響範囲を限定
4. **再利用性** - 下位層の機能を複数の上位層で活用
5. **チーム開発** - 層ごとに分担開発が可能

---

## 🏢 投資ダッシュボード v2 のレイヤー構成

```
投資ダッシュボード v2 アーキテクチャ
┌─────────────────────────────────────┐
│  🖼️  Presentation Layer (UI層)      │  ← ユーザーとの接点
│  src/ui/                           │
│  ├── views/     (HTML描画)          │
│  ├── controllers/ (イベント制御)      │
│  └── components/ (再利用部品)        │
├─────────────────────────────────────┤
│  🧠  Application Layer (Services層)  │  ← ビジネス処理の編成
│  src/services/                     │
│  └── CsvImportService.js           │
├─────────────────────────────────────┤
│  💼  Business Layer (ドメイン層)      │  ← ビジネスルール・計算
│  src/business/                     │
│  ├── services/ (分析・計算)          │
│  ├── models/   (エンティティ)        │
│  └── analysis/ (複雑計算)           │
├─────────────────────────────────────┤
│  🏪  Data Layer (データ層)           │  ← データ管理・永続化
│  src/data/                         │
│  ├── managers/   (LocalStorage)     │
│  └── repositories/ (CRUD操作)       │
├─────────────────────────────────────┤
│  🔌  Infrastructure Layer (基盤層)   │  ← 外部連携・技術的機能
│  src/infrastructure/               │
│  └── parsers/ (CSV解析等)           │
└─────────────────────────────────────┘
```

### 📋 各層の詳細説明

#### 🖼️ **Presentation Layer（プレゼンテーション層）**
- **責務**: ユーザーインターフェース、イベント処理、画面制御
- **今日の例**: `DatabaseController.js` - データベース画面の制御
- **学習ポイント**: MVCパターンのViewとController部分

#### 🧠 **Application Layer（アプリケーション層）**  
- **責務**: ユースケースの編成、複数のBusiness Layerサービスの調整
- **今日の例**: `CsvImportService.js` - CSV取り込みの一連の流れを管理
- **学習ポイント**: 複数の下位層を組み合わせて1つの機能を実現

#### 💼 **Business Layer（ビジネス層）**
- **責務**: ビジネスロジック、計算処理、ドメインルール
- **今日の例**: `SectorService.js` - セクター分類とリスク分析
- **学習ポイント**: ビジネスの「知識」をコードで表現

#### 🏪 **Data Layer（データ層）**
- **責務**: データの永続化、CRUD操作、LocalStorage管理
- **今日の例**: `DataStoreManager.js` - LocalStorageのデータ管理
- **学習ポイント**: データの保存・取得の抽象化

#### 🔌 **Infrastructure Layer（基盤層）**
- **責務**: 外部システム連携、技術的ユーティリティ
- **今日の例**: `RakutenCsvParser.js` - 楽天証券CSVの解析
- **学習ポイント**: 外部依存を隔離し、技術的複雑さを隠蔽

---

## 🎯 今日の開発作業詳細

### 📋 タスク完了状況 (7/7項目)

| No | タスク内容 | 状態 | 所要時間 | 成果 |
|----|------------|------|----------|------|
| 1 | 進捗状況確認 | ✅ | 10分 | プロジェクト構造把握 |
| 2 | 実装状況把握 | ✅ | 15分 | 変更ファイル確認 |
| 3 | 開発目標設定 | ✅ | 5分 | 2時間計画立案 |
| 4 | アプリ動作確認 | ✅ | 20分 | http://localhost:3000 検証 |
| 5 | RakutenCsvParser統合 | ✅ | 40分 | Shift-JIS対応実現 |
| 6 | CSV連携テスト | ✅ | 20分 | 統合テスト環境構築 |
| 7 | SectorService統合 | ✅ | 30分 | HHI指数分析追加 |

---

## 🔧 実装されたファイルと責務分析

### 1️⃣ **Infrastructure Layer統合**

#### 📁 `src/infrastructure/parsers/RakutenCsvParser.js`

**レイヤードアーキテクチャ上の位置付け:**
```
Infrastructure Layer (基盤層)
└── parsers/ ← 外部データ形式の解析を担当
    └── RakutenCsvParser.js ← 楽天証券CSV専用パーサー
```

**アーキテクチャ学習ポイント:**
- **単一責務の原則**: CSV解析のみに特化
- **依存関係の逆転**: 上位層が下位層の実装を知らない
- **技術的複雑さの隠蔽**: Shift-JISエンコーディングを内部で処理

**主要機能:**
```javascript
class RakutenCsvParser {
    // 🎯 責務: 楽天証券CSVの解析のみ
    async parseCsvFile(file, csvType, progressCallback) {
        // 1. Shift-JIS正常読み込み
        // 2. Papa Parseでデータ変換
        // 3. 投資ダッシュボード標準形式に変換
    }
    
    // 💡 学習ポイント: エンコーディング問題を完全に隠蔽
    async readCsvFileWithProperEncoding(file) {
        // 複数エンコーディング自動試行
    }
}
```

**アーキテクチャ的メリット:**
- 他の層はCSVの技術的詳細を知る必要がない
- エンコーディング変更時は、この層のみ修正すれば良い
- テストが容易（CSVファイル与えて期待値確認）

### 2️⃣ **Business Layer統合**

#### 📁 `src/business/services/SectorService.js`

**レイヤードアーキテクチャ上の位置付け:**
```
Business Layer (ビジネス層)
└── services/ ← ビジネスロジックサービス
    └── SectorService.js ← セクター分析の専門知識
```

**アーキテクチャ学習ポイント:**
- **ドメイン知識の集約**: 投資業界の「セクター分類」という知識
- **ビジネスルールの実装**: 東証33業種・GICS分類という業界標準
- **計算ロジックの抽象化**: HHI指数という金融工学

**主要機能:**
```javascript
class SectorService {
    // 🎯 責務: 投資のセクター分析という「業務知識」
    
    // 💡 ビジネス知識: 東証33業種分類
    sectorMaster = {
        JP: { '7203': { sector: 'トヨタ自動車', subSector: '自動車' } },
        US: { 'AAPL': { sector: 'Technology', subSector: 'Hardware' } }
    };
    
    // 💡 金融工学: HHI指数による集中リスク計算
    calculateConcentrationRisk(sectorAllocation) {
        const hhi = sectorAllocation.reduce((sum, sector) => {
            return sum + Math.pow(sector.percentage, 2);
        }, 0);
        // リスクレベル判定ロジック
    }
}
```

**アーキテクチャ的メリット:**
- 投資の専門知識が一箇所に集約
- UI層は「どう表示するか」に集中できる
- 金融アルゴリズムの変更時は、この層のみ修正

### 3️⃣ **Application Layer統合**

#### 📁 `src/services/CsvImportService.js`

**レイヤードアーキテクチャ上の位置付け:**
```
Application Layer (アプリケーション層)
└── CsvImportService.js ← 複数層を組み合わせたユースケース
    ├── Infrastructure Layer (RakutenCsvParser) を使用
    ├── Business Layer (SectorService) を使用
    └── Data Layer (AssetRepository) を使用
```

**アーキテクチャ学習ポイント:**
- **オーケストレーション**: 複数の下位層サービスを調整
- **ユースケース実現**: 「CSV取り込み」という業務フローを実装
- **トランザクション境界**: 一連の処理の成功/失敗を管理

**処理フロー例:**
```javascript
async parseAndPreview(file, csvType, progressCallback) {
    // 1. Infrastructure Layer: CSV解析
    const parseResult = await this.parser.parseCsvFile(file, csvType, progressCallback);
    
    // 2. Business Layer: データ変換・検証 (今後)
    // 3. Data Layer: 一時保存 (今後)
    
    // 複数層の結果を統合して返却
    return compatibleResult;
}
```

**アーキテクチャ的メリット:**
- 複雑な業務フローが理解しやすい
- 各層の変更が上位に影響しない
- テストで業務シナリオを検証できる

---

## 🧪 テスト環境と動作確認

### 🔗 統合テストページ
**URL**: http://localhost:3000/csv_parser_test.html

**アーキテクチャ学習ポイント:**
- **結合テスト**: 複数の層が連携して動作することを確認
- **境界値テスト**: 各層の境界での入出力を検証

**テスト項目:**
1. **Infrastructure Layer単体**: RakutenCsvParserの基本機能
2. **Application Layer統合**: CsvImportServiceとの連携
3. **実ファイル解析**: 楽天証券CSVの実際の処理

---

## 📊 アーキテクチャの依存関係図

```
依存関係の方向 (上位 → 下位のみ許可)
┌──────────────────────────────────────┐
│  UI Layer                            │
│  └── CsvImportController             │ ← ユーザー操作を受付
│      │                              │
│      ▼                              │
├──────────────────────────────────────┤
│  Application Layer                   │
│  └── CsvImportService                │ ← 業務フローを編成
│      │                              │
│      ▼                              │
├──────────────────────────────────────┤
│  Business Layer                      │
│  └── SectorService                   │ ← ビジネスルール実装
│      │                              │
│      ▼                              │
├──────────────────────────────────────┤
│  Data Layer                          │
│  └── DataStoreManager                │ ← データ永続化
│      │                              │
│      ▼                              │
├──────────────────────────────────────┤
│  Infrastructure Layer                │
│  └── RakutenCsvParser                │ ← 外部技術連携
└──────────────────────────────────────┘
```

**🚫 禁止されている依存関係:**
- Infrastructure Layer → Business Layer ❌
- Data Layer → Application Layer ❌
- 下位層が上位層を知ること ❌

**✅ 正しい依存関係:**
- 上位層 → 下位層のみ ✅
- 同一層内での横の依存 ✅ (設計による)

---

## 🎓 レイヤードアーキテクチャの学習成果

### 📚 理解できたポイント

1. **責務の分離**
   - 各層が明確な役割を持つ
   - CSV解析 vs セクター計算 vs データ保存

2. **依存関係の管理**
   - 上位から下位への一方向のみ
   - 変更時の影響範囲を限定

3. **抽象化レベル**
   - 下に行くほど技術的・具体的
   - 上に行くほどビジネス的・抽象的

4. **テスタビリティ**
   - 各層を独立してテスト可能
   - モックを使った単体テスト

### 🔍 実際のコード例で学ぶ

**❌ 悪い例（レイヤー違反）:**
```javascript
// UI LayerでCSVの技術的詳細を直接扱う（悪い例）
class DatabaseController {
    async importCsv(file) {
        // ❌ UI層で技術的詳細（Shift-JIS）を扱っている
        const reader = new FileReader();
        reader.readAsText(file, 'Shift_JIS');
        // ❌ UI層でビジネスロジック（セクター計算）を実装
        const sector = code.startsWith('7') ? '自動車' : 'その他';
    }
}
```

**✅ 良い例（適切な層分離）:**
```javascript
// UI Layer: 表示とイベント処理のみ
class DatabaseController {
    async importCsv(file) {
        // ✅ Application Layerに委譲
        const result = await this.csvImportService.parseAndPreview(file);
        this.view.showResult(result); // ✅ UI層は表示に集中
    }
}

// Application Layer: 業務フローの調整
class CsvImportService {
    async parseAndPreview(file) {
        // ✅ Infrastructure Layerに委譲
        const parseResult = await this.parser.parseCsvFile(file);
        // ✅ Business Layerに委譲
        const withSectors = this.sectorService.assignSector(parseResult);
        return withSectors;
    }
}
```

---

## 🚀 今後の発展と学習方向

### 📈 次のステップ

1. **PortfolioAggregator.js統合**
   - Business Layerのanalysis/配下
   - ポートフォリオ集約計算の実装

2. **UIレイヤーの拡充**
   - 新機能のビジュアル表示
   - セクター分析チャートの実装

3. **Data Layerの強化**
   - より複雑なクエリ機能
   - データマイグレーション

### 🎯 アーキテクチャ学習の深化

1. **DDD (Domain Driven Design)**
   - より高度なBusiness Layer設計
   - エンティティとバリューオブジェクト

2. **CQRS (Command Query Responsibility Segregation)**
   - 読み取りと書き込みの分離
   - より複雑なデータ操作

3. **Clean Architecture**
   - Robert C. Martinの提唱するアーキテクチャ
   - 依存関係逆転の高度な活用

---

## 📝 今日の振り返り

### ✅ 達成できたこと

1. **技術統合**: 参照フォルダの高機能サービスをv2アーキテクチャに統合
2. **アーキテクチャ理解**: レイヤードアーキテクチャの実践的な適用
3. **品質向上**: Shift-JIS対応、HHI指数計算など実用的な機能追加
4. **テスト環境**: 統合テストページでの動作検証

### 🔍 学習できたこと

1. **責務分離の重要性**: 各層が明確な役割を持つことの価値
2. **依存関係管理**: 一方向依存によるメンテナンスの容易さ
3. **抽象化の力**: 技術的複雑さを隠蔽することでビジネスロジックに集中
4. **統合の難しさ**: 複数の層が連携する際の設計の重要性

### 💡 次回への提案

1. **UIレイヤーでの新機能表示**: セクター分析結果の可視化
2. **Business Layerの拡充**: PortfolioAggregator.jsの統合
3. **Performance層の追加**: 大量データ処理の最適化
4. **Testing層の強化**: 各層の単体・結合テスト

---

**開発記録作成者**: Claude Code  
**ユーザー**: 投資ダッシュボード開発者  
**記録日時**: 2025年9月21日  
**アーキテクチャ**: レイヤードアーキテクチャ v2.0

---

> 💡 **学習メモ**: レイヤードアーキテクチャは「分割統治」の考え方で、複雑なソフトウェアを管理可能な単位に分けて開発する手法です。今日の実装で、各層の責務分離と依存関係管理の重要性を実感できたかと思います。