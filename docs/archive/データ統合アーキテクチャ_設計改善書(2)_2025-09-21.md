# データ統合アーキテクチャ - 設計改善書

**作成日**: 2025年9月21日  
**問題**: 異なるCSV形式データの統一管理・標準化設計  
**プロジェクト**: 投資ダッシュボード v2  
**重要度**: 🔴 クリティカル（アーキテクチャ根幹問題）

---

## 🎯 問題の核心

### 💡 ユーザーの鋭い指摘
> 「列名の異なるデータをインポートするわけじゃないですか、だけど、それら全ても含めて色々計算とかグラフに出したりするわけで、その**共通の台帳のようなもの**ってどこで実装するのかなって思っています。」

### 🔍 現在の問題分析

```
❌ 現在の問題フロー
┌─────────────────────────────────────────────┐
│ Infrastructure Layer                        │
│ ├── RakutenCsvParser.js                     │
│ │   ├── JP形式 → 独自変換                   │
│ │   ├── US形式 → 独自変換                   │
│ │   └── INVST形式 → 独自変換                │
│ └── [各々が異なるフィールド名・構造]        │
└─────────────────────────────────────────────┘
              ⬇️ 問題：統一されていない
┌─────────────────────────────────────────────┐
│ Data Layer                                  │
│ └── DataStoreManager.js                     │
│     ├── addStock() ← JP/US混在              │
│     ├── addMutualFund() ← INVST混在         │
│     └── [同じテーブルに異質なデータ]        │
└─────────────────────────────────────────────┘
              ⬇️ 結果：分析・計算が困難
┌─────────────────────────────────────────────┐
│ Business Layer                              │
│ └── SectorService.js                        │
│     ├── calculateConcentrationRisk()        │
│     └── [フィールド名の不統一で計算エラー] │
└─────────────────────────────────────────────┘
```

---

## 🏗️ 正しいレイヤードアーキテクチャ設計

### 📋 設計原則

1. **Domain Model（ドメインモデル）**: ビジネス概念の統一表現
2. **Data Transformation**: 外部形式 → 内部標準形式
3. **Repository Pattern**: データアクセスの抽象化
4. **Single Source of Truth**: 統一された真実のデータ

### 🎯 改善後のアーキテクチャ

```
✅ 正しいデータ統合フロー
┌─────────────────────────────────────────────┐
│ 🔌 Infrastructure Layer                     │
│ ├── RakutenCsvParser.js                     │
│ │   ├── JP → TransactionEntity               │
│ │   ├── US → TransactionEntity               │
│ │   └── INVST → TransactionEntity            │
│ └── [共通のTransactionEntityに統一変換]     │
└─────────────────────────────────────────────┘
              ⬇️ 統一されたエンティティ
┌─────────────────────────────────────────────┐
│ 💼 Domain Layer (新設)                      │
│ ├── entities/                               │
│ │   ├── TransactionEntity.js                │
│ │   ├── AssetEntity.js                      │
│ │   └── PortfolioEntity.js                  │
│ └── [ビジネス概念の標準化定義]              │
└─────────────────────────────────────────────┘
              ⬇️ 標準化されたデータ
┌─────────────────────────────────────────────┐
│ 🏪 Data Layer                               │
│ ├── repositories/                           │
│ │   ├── TransactionRepository.js            │
│ │   ├── AssetRepository.js                  │
│ │   └── PortfolioRepository.js              │
│ └── [統一テーブル構造で管理]                │
└─────────────────────────────────────────────┘
              ⬇️ 統一データで分析
┌─────────────────────────────────────────────┐
│ 💼 Business Layer                           │
│ ├── PortfolioAggregator.js                  │
│ ├── SectorService.js                        │
│ └── [統一フィールドで確実な計算]            │
└─────────────────────────────────────────────┘
```

---

## 📐 Domain Model設計

### 🎯 **TransactionEntity** - 取引の統一表現

```javascript
/**
 * TransactionEntity - 全ての取引データの統一表現
 * 目的: JP株・US株・投資信託を統一フォーマットで表現
 */
export class TransactionEntity {
    constructor(data) {
        // === 基本情報（必須） ===
        this.id = data.id || this._generateId();
        this.transactionDate = data.transactionDate; // Date型、統一日付
        this.settlementDate = data.settlementDate;   // Date型、受渡日
        
        // === 資産識別（必須） ===
        this.assetName = data.assetName;            // string、統一銘柄名
        this.assetCode = data.assetCode || null;    // string、銘柄コード/ティッカー
        this.assetType = data.assetType;            // enum: 'stock'|'fund'|'etf'
        this.region = data.region;                  // enum: 'JP'|'US'|'OTHER'
        
        // === 取引詳細（必須） ===
        this.tradeType = data.tradeType;            // enum: 'buy'|'sell'|'dividend'
        this.quantity = data.quantity;              // number、数量（株数・口数）
        this.unitPrice = data.unitPrice;            // number、単価
        this.amount = data.amount;                  // number、約定代金
        
        // === 金額情報（必須・円換算） ===
        this.amountJpy = data.amountJpy;            // number、円換算金額
        this.unitPriceJpy = data.unitPriceJpy;      // number、円換算単価
        this.currency = data.currency || 'JPY';    // string、元通貨
        this.exchangeRate = data.exchangeRate || 1; // number、為替レート
        
        // === 手数料・税金（オプション） ===
        this.fee = data.fee || 0;                   // number、手数料
        this.tax = data.tax || 0;                   // number、税金
        this.otherCosts = data.otherCosts || 0;     // number、その他費用
        
        // === 口座情報（オプション） ===
        this.accountType = data.accountType || 'general'; // enum: 'general'|'nisa'|'isa'
        this.provider = data.provider || 'unknown';       // string、証券会社
        
        // === メタデータ（システム） ===
        this.source = data.source || 'manual';     // string、データソース
        this.sourceFormat = data.sourceFormat;     // string、元CSV形式
        this.createdAt = data.createdAt || new Date();
        this.updatedAt = data.updatedAt || new Date();
        
        // === 拡張フィールド（将来用） ===
        this.metadata = data.metadata || {};       // object、追加情報
    }

    /**
     * バリデーション
     */
    validate() {
        const errors = [];
        
        if (!this.transactionDate) errors.push('取引日は必須です');
        if (!this.assetName) errors.push('銘柄名は必須です');
        if (!this.assetType) errors.push('資産種別は必須です');
        if (!this.tradeType) errors.push('売買区分は必須です');
        if (this.quantity <= 0) errors.push('数量は正の値である必要があります');
        if (this.amount <= 0) errors.push('金額は正の値である必要があります');
        
        return {
            isValid: errors.length === 0,
            errors
        };
    }

    /**
     * 円換算金額を自動計算
     */
    calculateJpyAmounts() {
        if (this.currency === 'JPY') {
            this.amountJpy = this.amount;
            this.unitPriceJpy = this.unitPrice;
        } else {
            this.amountJpy = this.amount * this.exchangeRate;
            this.unitPriceJpy = this.unitPrice * this.exchangeRate;
        }
    }

    /**
     * ポートフォリオ集約用の標準化データ取得
     */
    toAggregationFormat() {
        return {
            id: this.id,
            date: this.transactionDate,
            assetName: this.assetName,
            assetCode: this.assetCode,
            assetType: this.assetType,
            region: this.region,
            tradeType: this.tradeType,
            quantity: this.quantity,
            amountJpy: this.amountJpy,
            unitPriceJpy: this.unitPriceJpy,
            accountType: this.accountType,
            provider: this.provider
        };
    }
}
```

### 🎯 **AssetEntity** - 資産の統一表現

```javascript
/**
 * AssetEntity - 集約された資産データの統一表現
 * 目的: 取引履歴から集約された現在の保有資産状況
 */
export class AssetEntity {
    constructor(data) {
        // === 資産識別 ===
        this.id = data.id || this._generateId();
        this.assetName = data.assetName;
        this.assetCode = data.assetCode;
        this.assetType = data.assetType;
        this.region = data.region;
        
        // === 保有状況 ===
        this.currentQuantity = data.currentQuantity || 0;
        this.currentValueJpy = data.currentValueJpy || 0;
        this.acquisitionCostJpy = data.acquisitionCostJpy || 0;
        this.gainLossJpy = data.gainLossJpy || 0;
        this.gainLossPercent = data.gainLossPercent || 0;
        
        // === セクター情報（SectorServiceから付与） ===
        this.sector = data.sector || null;
        this.subSector = data.subSector || null;
        this.sectorSource = data.sectorSource || null;
        
        // === 口座・メタ情報 ===
        this.accountType = data.accountType;
        this.provider = data.provider;
        this.firstPurchaseDate = data.firstPurchaseDate;
        this.lastUpdateDate = data.lastUpdateDate;
        
        // === 取引履歴サマリー ===
        this.totalTransactions = data.totalTransactions || 0;
        this.totalBuyQuantity = data.totalBuyQuantity || 0;
        this.totalSellQuantity = data.totalSellQuantity || 0;
        this.averageUnitPrice = data.averageUnitPrice || 0;
    }
}
```

---

## 🔧 Infrastructure Layer改修

### 🎯 **RakutenCsvParser v3.0** - 統一エンティティへの変換

```javascript
/**
 * RakutenCsvParser v3.0 - TransactionEntityへの統一変換
 */
export class RakutenCsvParser {
    
    /**
     * CSVデータをTransactionEntityに変換
     */
    async parseCsvFile(file, csvType, progressCallback) {
        // ... 既存の読み込み処理
        
        // 🆕 統一エンティティへの変換
        const transactions = rawData.map(row => 
            this.convertToTransactionEntity(row, csvType)
        );
        
        return {
            success: true,
            entities: transactions,  // 🆕 統一エンティティ配列
            metadata: {
                totalCount: transactions.length,
                validCount: transactions.filter(t => t.validate().isValid).length,
                sourceFormat: csvType,
                parseDate: new Date().toISOString()
            }
        };
    }

    /**
     * 各CSV形式をTransactionEntityに変換
     */
    convertToTransactionEntity(row, csvType) {
        switch (csvType) {
            case 'JP':
                return this.convertJpStockToEntity(row);
            case 'US':
                return this.convertUsStockToEntity(row);
            case 'INVST':
                return this.convertInvestmentTrustToEntity(row);
            default:
                throw new Error(`未対応のCSV形式: ${csvType}`);
        }
    }

    /**
     * JP株式 → TransactionEntity変換
     */
    convertJpStockToEntity(row) {
        return new TransactionEntity({
            transactionDate: this.parseDate(row['約定日']),
            settlementDate: this.parseDate(row['受渡日']),
            assetName: row['銘柄名'],
            assetCode: row['銘柄コード'],
            assetType: 'stock',
            region: 'JP',
            tradeType: this.normalizeTradeType(row['売買区分']),
            quantity: this.parseNumber(row['数量［株］']),
            unitPrice: this.parseNumber(row['単価［円］']),
            amount: this.parseNumber(row['受渡金額［円］']),
            amountJpy: this.parseNumber(row['受渡金額［円］']),
            unitPriceJpy: this.parseNumber(row['単価［円］']),
            currency: 'JPY',
            exchangeRate: 1,
            fee: this.parseNumber(row['手数料［円］']),
            tax: this.parseNumber(row['税金等［円］']),
            accountType: this.normalizeAccountType(row['口座区分']),
            provider: '楽天証券',
            source: 'rakuten_csv',
            sourceFormat: 'JP'
        });
    }

    /**
     * US株式 → TransactionEntity変換
     */
    convertUsStockToEntity(row) {
        return new TransactionEntity({
            transactionDate: this.parseDate(row['約定日']),
            settlementDate: this.parseDate(row['受渡日']),
            assetName: row['銘柄名'],
            assetCode: row['ティッカー'],
            assetType: 'stock',
            region: 'US',
            tradeType: this.normalizeTradeType(row['売買区分']),
            quantity: this.parseNumber(row['数量［株］']),
            unitPrice: this.parseNumber(row['単価［USドル］']),
            amount: this.parseNumber(row['受渡金額［USドル］']),
            amountJpy: this.parseNumber(row['受渡金額［円］']),
            unitPriceJpy: this.calculateJpyUnitPrice(row),
            currency: 'USD',
            exchangeRate: this.parseNumber(row['為替レート']),
            fee: this.parseNumber(row['手数料［USドル］']),
            tax: this.parseNumber(row['税金［USドル］']),
            accountType: this.normalizeAccountType(row['口座']),
            provider: '楽天証券',
            source: 'rakuten_csv',
            sourceFormat: 'US'
        });
    }

    /**
     * 投資信託 → TransactionEntity変換
     */
    convertInvestmentTrustToEntity(row) {
        const complexAmount = this.parseComplexAmount(row['受渡金額/(ポイント利用)[円]']);
        
        return new TransactionEntity({
            transactionDate: this.parseDate(row['約定日']),
            settlementDate: this.parseDate(row['受渡日']),
            assetName: row['ファンド名'],
            assetCode: null, // 投資信託にはコードなし
            assetType: 'fund',
            region: this.inferRegionFromFundName(row['ファンド名']),
            tradeType: this.normalizeTradeType(row['取引']),
            quantity: this.parseNumber(row['数量［口］']),
            unitPrice: this.parseNumber(row['単価']),
            amount: complexAmount.amount,
            amountJpy: complexAmount.amount,
            unitPriceJpy: this.parseNumber(row['単価']),
            currency: 'JPY',
            exchangeRate: 1,
            accountType: this.normalizeAccountType(row['口座']),
            provider: '楽天証券',
            source: 'rakuten_csv',
            sourceFormat: 'INVST',
            metadata: {
                pointUsed: complexAmount.pointUsed, // ポイント利用額
                purchaseMethod: row['買付方法']
            }
        });
    }
}
```

---

## 🏪 Data Layer改修

### 🎯 **Repository Pattern実装**

```javascript
/**
 * TransactionRepository - 取引データの統一管理
 */
export class TransactionRepository {
    constructor(dataStoreManager) {
        this.dataStore = dataStoreManager;
        this.STORAGE_KEY = 'unified_transactions';
    }

    /**
     * 取引データを保存（統一エンティティ）
     */
    async saveTransactions(transactionEntities) {
        // バリデーション
        const validTransactions = [];
        const errors = [];

        for (const transaction of transactionEntities) {
            const validation = transaction.validate();
            if (validation.isValid) {
                validTransactions.push(transaction);
            } else {
                errors.push({ transaction: transaction.id, errors: validation.errors });
            }
        }

        // 既存データと統合
        const existingTransactions = await this.getAllTransactions();
        const allTransactions = [...existingTransactions, ...validTransactions];

        // 重複除去（同じIDの取引は上書き）
        const uniqueTransactions = this.removeDuplicates(allTransactions);

        // 保存
        const success = this.dataStore.save(this.STORAGE_KEY, uniqueTransactions);

        return {
            success,
            savedCount: validTransactions.length,
            errorCount: errors.length,
            errors,
            totalTransactions: uniqueTransactions.length
        };
    }

    /**
     * 全取引データ取得
     */
    async getAllTransactions() {
        const data = this.dataStore.load(this.STORAGE_KEY) || [];
        return data.map(item => new TransactionEntity(item));
    }

    /**
     * 条件による取引データ検索
     */
    async findTransactions(criteria) {
        const allTransactions = await this.getAllTransactions();
        
        return allTransactions.filter(transaction => {
            if (criteria.assetType && transaction.assetType !== criteria.assetType) return false;
            if (criteria.region && transaction.region !== criteria.region) return false;
            if (criteria.provider && transaction.provider !== criteria.provider) return false;
            if (criteria.accountType && transaction.accountType !== criteria.accountType) return false;
            if (criteria.dateFrom && transaction.transactionDate < criteria.dateFrom) return false;
            if (criteria.dateTo && transaction.transactionDate > criteria.dateTo) return false;
            return true;
        });
    }

    /**
     * 資産別取引履歴取得
     */
    async getTransactionsByAsset(assetCode) {
        const criteria = { assetCode };
        return await this.findTransactions(criteria);
    }
}

/**
 * AssetRepository - 集約資産データの管理
 */
export class AssetRepository {
    constructor(dataStoreManager, transactionRepository) {
        this.dataStore = dataStoreManager;
        this.transactionRepo = transactionRepository;
        this.STORAGE_KEY = 'aggregated_assets';
    }

    /**
     * 取引履歴から資産を集約
     */
    async aggregateAssetsFromTransactions() {
        const transactions = await this.transactionRepo.getAllTransactions();
        const assetMap = new Map();

        // 資産別に取引をグループ化
        for (const transaction of transactions) {
            const key = `${transaction.assetCode || transaction.assetName}_${transaction.region}`;
            
            if (!assetMap.has(key)) {
                assetMap.set(key, {
                    assetName: transaction.assetName,
                    assetCode: transaction.assetCode,
                    assetType: transaction.assetType,
                    region: transaction.region,
                    transactions: []
                });
            }
            
            assetMap.get(key).transactions.push(transaction);
        }

        // 各資産の集約計算
        const aggregatedAssets = [];
        for (const [key, assetData] of assetMap) {
            const asset = this.calculateAssetSummary(assetData);
            aggregatedAssets.push(asset);
        }

        // 保存
        await this.saveAggregatedAssets(aggregatedAssets);
        return aggregatedAssets;
    }

    /**
     * 資産サマリー計算
     */
    calculateAssetSummary(assetData) {
        const transactions = assetData.transactions;
        let currentQuantity = 0;
        let totalAcquisitionCost = 0;
        let totalBuyQuantity = 0;
        let totalSellQuantity = 0;

        // 取引を時系列でソート
        transactions.sort((a, b) => a.transactionDate - b.transactionDate);

        for (const tx of transactions) {
            if (tx.tradeType === 'buy') {
                currentQuantity += tx.quantity;
                totalAcquisitionCost += tx.amountJpy;
                totalBuyQuantity += tx.quantity;
            } else if (tx.tradeType === 'sell') {
                currentQuantity -= tx.quantity;
                totalSellQuantity += tx.quantity;
                // FIFO法で取得原価を減額（簡略化）
                const sellRatio = tx.quantity / (currentQuantity + tx.quantity);
                totalAcquisitionCost *= (1 - sellRatio);
            }
        }

        const averageUnitPrice = totalBuyQuantity > 0 ? totalAcquisitionCost / totalBuyQuantity : 0;
        
        return new AssetEntity({
            assetName: assetData.assetName,
            assetCode: assetData.assetCode,
            assetType: assetData.assetType,
            region: assetData.region,
            currentQuantity,
            acquisitionCostJpy: totalAcquisitionCost,
            totalTransactions: transactions.length,
            totalBuyQuantity,
            totalSellQuantity,
            averageUnitPrice,
            firstPurchaseDate: transactions[0]?.transactionDate,
            lastUpdateDate: transactions[transactions.length - 1]?.transactionDate
        });
    }
}
```

---

## 💼 Business Layer統合

### 🎯 **PortfolioAggregator v3.0** - 統一データ活用

```javascript
/**
 * PortfolioAggregator v3.0 - 統一エンティティベースの集約
 */
export class PortfolioAggregator {
    constructor(transactionRepository, assetRepository, sectorService) {
        this.transactionRepo = transactionRepository;
        this.assetRepo = assetRepository;
        this.sectorService = sectorService;
    }

    /**
     * 包括的なポートフォリオ分析
     */
    async generatePortfolioAnalysis() {
        // 1. 最新の資産集約
        const assets = await this.assetRepo.aggregateAssetsFromTransactions();
        
        // 2. セクター情報付与
        const assetsWithSectors = assets.map(asset => 
            this.sectorService.assignSector(asset)
        );
        
        // 3. 地域別分析
        const regionAnalysis = this.analyzeByRegion(assetsWithSectors);
        
        // 4. セクター分析
        const sectorAnalysis = this.sectorService.generateSectorAnalysis(assetsWithSectors);
        
        // 5. パフォーマンス分析
        const performanceAnalysis = await this.analyzePerformance(assets);
        
        return {
            summary: {
                totalAssets: assets.length,
                totalValueJpy: assetsWithSectors.reduce((sum, a) => sum + a.currentValueJpy, 0),
                totalGainLossJpy: assetsWithSectors.reduce((sum, a) => sum + a.gainLossJpy, 0)
            },
            regional: regionAnalysis,
            sectoral: sectorAnalysis,
            performance: performanceAnalysis,
            assets: assetsWithSectors,
            generatedAt: new Date().toISOString()
        };
    }

    /**
     * 地域別分析
     */
    analyzeByRegion(assets) {
        const regionMap = new Map();
        
        for (const asset of assets) {
            if (!regionMap.has(asset.region)) {
                regionMap.set(asset.region, {
                    region: asset.region,
                    assetCount: 0,
                    totalValue: 0,
                    totalGainLoss: 0,
                    assets: []
                });
            }
            
            const regionData = regionMap.get(asset.region);
            regionData.assetCount++;
            regionData.totalValue += asset.currentValueJpy;
            regionData.totalGainLoss += asset.gainLossJpy;
            regionData.assets.push(asset);
        }
        
        return Array.from(regionMap.values());
    }
}
```

---

## 🔄 データフロー全体像

### ✅ **改善後の完全なフロー**

```
📁 楽天証券CSV (3形式)
    ⬇️
🔌 RakutenCsvParser v3.0
    ├── convertJpStockToEntity()
    ├── convertUsStockToEntity()
    └── convertInvestmentTrustToEntity()
    ⬇️ [TransactionEntity統一形式]
🏪 TransactionRepository
    └── saveTransactions(entities[])
    ⬇️ [統一データベース]
🏪 AssetRepository
    └── aggregateAssetsFromTransactions()
    ⬇️ [AssetEntity集約済み]
💼 SectorService
    └── assignSector(asset) → sector付与
    ⬇️ [完全な分析用データ]
💼 PortfolioAggregator
    ├── generatePortfolioAnalysis()
    ├── analyzeByRegion()
    └── calculatePerformance()
    ⬇️ [統合分析結果]
🖼️ UI Layer
    ├── ダッシュボード表示
    ├── セクターチャート
    └── パフォーマンスグラフ
```

---

## 📋 実装優先度

### 🔴 **Phase 1: 基盤構築（高優先度）**
1. **TransactionEntity設計・実装**
2. **RakutenCsvParser v3.0改修**（統一エンティティ対応）
3. **TransactionRepository基本実装**
4. **既存DataStoreManagerとの統合**

### 🟡 **Phase 2: 集約機能（中優先度）**
1. **AssetRepository実装**
2. **資産集約ロジック実装**
3. **SectorService統合テスト**
4. **データマイグレーション機能**

### 🟢 **Phase 3: 分析強化（低優先度）**
1. **PortfolioAggregator高度分析**
2. **パフォーマンス計算エンジン**
3. **レポート生成機能**
4. **UI層でのデータ可視化**

---

## 🎯 レイヤードアーキテクチャ最適化

### 📐 **新しいレイヤー構成**

```
投資ダッシュボード v3 - 改善版アーキテクチャ
┌─────────────────────────────────────┐
│  🖼️  Presentation Layer             │  ← UI・ユーザー操作
├─────────────────────────────────────┤
│  🧠  Application Layer              │  ← ユースケース編成
├─────────────────────────────────────┤
│  💼  Business Layer                 │  ← ビジネスロジック・分析
├─────────────────────────────────────┤
│  🏗️  Domain Layer ⭐ NEW            │  ← エンティティ・ドメインモデル
├─────────────────────────────────────┤
│  🏪  Data Layer                     │  ← Repository・データアクセス
├─────────────────────────────────────┤
│  🔌  Infrastructure Layer           │  ← 外部システム連携
└─────────────────────────────────────┘
```

### 🎯 **各層の責務明確化**

| 層 | 責務 | 実装例 |
|----|----|-------|
| **Domain Layer** | エンティティ定義・ビジネス概念統一 | TransactionEntity, AssetEntity |
| **Data Layer** | データアクセス抽象化・永続化 | TransactionRepository, AssetRepository |
| **Business Layer** | ビジネスロジック・分析 | PortfolioAggregator, SectorService |
| **Infrastructure** | 外部形式変換・技術的処理 | RakutenCsvParser, ExternalAPI |

---

## 💡 **結論**

この設計改善により：

1. **データ統一**: 全ての取引が同一形式で管理される
2. **分析精度**: 統一フィールドによる確実な計算
3. **拡張性**: 新しいCSV形式・証券会社への対応が容易
4. **保守性**: レイヤー責務の明確化
5. **テスタビリティ**: 各層の独立テストが可能

**共通の台帳**は **Domain Layer の TransactionEntity/AssetEntity** として実現され、すべての分析・計算機能の基盤となります。

**設計改善書作成者**: Claude Code  
**承認**: 投資ダッシュボード v2 開発チーム  
**実装開始**: 2025年9月21日